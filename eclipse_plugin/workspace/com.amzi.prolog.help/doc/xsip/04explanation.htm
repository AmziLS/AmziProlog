<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=windows-1252">
<TITLE>4 Explanation</TITLE>
</HEAD>
<BODY bgcolor="#ffffff">
<h1><a name="Explanation"></a><B><FONT FACE="New Century Schlbk,Century Schoolbook"> 4 
  Explanation </font></B></h1>
<P ALIGN="JUSTIFY"><FONT FACE="New Century Schlbk,Century Schoolbook" SIZE=2>It 
  is often claimed that an important aspect of expert systems is the ability to 
  explain their behavior. This means the user can ask the system for justification 
  of conclusions or questions at any point in a consultation with an expert system. 
  The system usually responds with the rules that were used for the conclusion, 
  or the rules being considered which led to a question to the user.</FONT></P>
<h3><B><FONT FACE="New Century Schlbk,Century Schoolbook"><a name="valueofexplanationstotheuser"></a>Value 
  of Explanations to the User</FONT></B></h3>
<P ALIGN="JUSTIFY"><FONT FACE="New Century Schlbk,Century Schoolbook" SIZE=2>The 
  importance of this feature is probably overestimated for the user. Typically 
  the user just wants the answer. Furthermore, when the user does want an explanation, 
  the explanation is not always useful. This is due to the nature of the "intelligence" 
  in an expert system.</FONT></P>
<P ALIGN="JUSTIFY"><FONT FACE="New Century Schlbk,Century Schoolbook" SIZE=2>The 
  rules typically reflect empirical, or "compiled" knowledge. They are codifications 
  of an expert's rules of thumb, not the expert's deeper understanding which led 
  to the rules of thumb. For example, consider the following dialog with an expert 
  system designed to give advice on car problems:</FONT></P>
<DIR> 
  <DIR> <B> </b> 
    <P><FONT FACE="New Century Schlbk,Century Schoolbook" SIZE=2>Does the car 
      start?<B> no.</b></FONT></P>
    <P><FONT FACE="New Century Schlbk,Century Schoolbook" SIZE=2>Does the engine 
      turn over?<B> yes.</b></FONT></P>
    <P><FONT FACE="New Century Schlbk,Century Schoolbook" SIZE=2>Do you smell 
      gas?<B> yes.</b></FONT></P>
    <P><FONT FACE="New Century Schlbk,Century Schoolbook" SIZE=2>Recommendation 
      - Wait 5 minutes and try again.</FONT></P>
    <P><FONT FACE="New Century Schlbk,Century Schoolbook" SIZE=2><B>why?</B></FONT></P>
    <P><FONT FACE="New Century Schlbk,Century Schoolbook" SIZE=2>I used the rule:<BR>
      If&#9;not start, and<BR>
      &#9;engine_turn_over, and<BR>
      &#9;smell_gas<BR>
      Then&#9;recommend is 'Wait 5 minutes and try again.'.</FONT></P>
  </DIR>
</DIR>
<P ALIGN="JUSTIFY"><FONT FACE="New Century Schlbk,Century Schoolbook" SIZE=2>The 
  rule gives the correct advice for a flooded car, and knows the questions to 
  ask to determine if the car is flooded, but it does not contain the knowledge 
  of what a flooded car is and why waiting will help. If the user really wanted 
  to understand what was happening, he/she would need a short dissertation on 
  carburetors, how they behave, and their relationship to the gas pedal.</FONT></P>
<P ALIGN="JUSTIFY"><FONT FACE="New Century Schlbk,Century Schoolbook" SIZE=2>For 
  a system such as this to have useful explanations, it would need to do more 
  than parrot the rules used. One approach is to annotate the rules with deeper 
  explanations. This is illustrated in chapter 10. Another approach being actively 
  researched is to encode the deeper knowledge into the system and use it to drive 
  both the inference and the explanations.</FONT></P>
<P ALIGN="JUSTIFY"><FONT FACE="New Century Schlbk,Century Schoolbook" SIZE=2>On 
  the other hand, there are some systems in which the expert's knowledge is just 
  empirical knowledge. In this case, the system's explanation is useful to the 
  user. Classification systems such as the bird identification system fall in 
  this category. The Bird system would explain an identification of a laysan albatross 
  with the rule used to identify it. There is no underlying theory as to why a 
  white albatross is a laysan albatross and a dark one is a black footed albatross. 
  That is simply the rule used to classify them.</FONT></P>
<h3 ALIGN="JUSTIFY"><B><FONT FACE="New Century Schlbk,Century Schoolbook"><a name="valueofexplanationstothedeveloper"></a>Value 
  of Explanations to the Developer</FONT></B></h3>
<P ALIGN="JUSTIFY"><FONT FACE="New Century Schlbk,Century Schoolbook" SIZE=2>While 
  an explanation feature might be of questionable value to the user of the system, 
  it is invaluable to the developer of the system. It serves the same diagnostic 
  purpose as program tracing for conventional programs. When the system is not 
  behaving correctly, the expert can use the explanations to find the rules which 
  are in error. The knowledge engineer uses the explanations to better tune the 
  knowledge base to have more realistic dialogs with the user.</FONT></P>
<h3 ALIGN="JUSTIFY"><B><FONT FACE="New Century Schlbk,Century Schoolbook"><a name="typesofexplanations"></a>Types 
  of Explanation</FONT></B></h3>
<P ALIGN="JUSTIFY"><FONT FACE="New Century Schlbk,Century Schoolbook" SIZE=2>There 
  are four types of explanations commonly used in expert systems. We will implement 
  most of these in both the Clam shell and the Native shell:</FONT></P>
<P ALIGN="JUSTIFY"> 
<FONT FACE="New Century Schlbk,Century Schoolbook" SIZE=2> 
<P ALIGN="JUSTIFY"> </P>
</FONT> 
<DIR> 
  <DIR> 
    <P ALIGN="JUSTIFY"><FONT FACE="New Century Schlbk,Century Schoolbook" SIZE=2>•&#9;a 
      rule trace which reports on the progress of a consultation;</FONT></P>
    <P ALIGN="JUSTIFY"> 
    <FONT FACE="New Century Schlbk,Century Schoolbook" SIZE=2> 
    <P ALIGN="JUSTIFY"> </P>
    </FONT> 
    <P ALIGN="JUSTIFY"><FONT FACE="New Century Schlbk,Century Schoolbook" SIZE=2>•&#9;explanation 
      of <B>how</B> the system reached a given conclusion;</FONT></P>
    <P ALIGN="JUSTIFY"> 
    <FONT FACE="New Century Schlbk,Century Schoolbook" SIZE=2> 
    <P ALIGN="JUSTIFY"> </P>
    </FONT> 
    <P ALIGN="JUSTIFY"><FONT FACE="New Century Schlbk,Century Schoolbook" SIZE=2>•&#9;explanation 
      of <B>why</B> the system is asking a question;</FONT></P>
    <P ALIGN="JUSTIFY"> 
    <FONT FACE="New Century Schlbk,Century Schoolbook" SIZE=2> 
    <P ALIGN="JUSTIFY"> </P>
    </FONT> 
    <P ALIGN="JUSTIFY"><FONT FACE="New Century Schlbk,Century Schoolbook" SIZE=2>•&#9;explanation 
      of <B>why not</B> a given conclusion.</FONT></P>
    <P ALIGN="JUSTIFY"> 
    <FONT FACE="New Century Schlbk,Century Schoolbook" SIZE=2> 
    <P ALIGN="JUSTIFY"> </P>
    </FONT> </DIR>
</DIR>
<P ALIGN="JUSTIFY"><FONT FACE="New Century Schlbk,Century Schoolbook" SIZE=2>Since 
  we wrote the inference engine for Clam it will not be difficult to modify it 
  to include these features. The Native system currently uses Prolog's inference 
  engine. In order to add explanation it will be necessary to write our own Prolog 
  inference engine. Fortunately it is not difficult to write Prolog in Prolog.</FONT></P>
<h2><B><FONT FACE="New Century Schlbk,Century Schoolbook"> <a name="explanationinclam"></a>4.1 
  Explanation in Clam </font></B></h2>
<P ALIGN="JUSTIFY"><FONT FACE="New Century Schlbk,Century Schoolbook" SIZE=2>First, 
  let's look at some examples of the explanation features of Clam using the Car 
  system. Here is how the user turns on tracing for the consultation, and the 
  results. The new trace information is in bold. It shows the sequence of rule 
  firings as they are expected. Notice in particular that it reports correctly 
  on the nesting of rules 2 and 3 within rule 1.</FONT></P>
<DIR> 
  <DIR> <B> </b> 
    <P><FONT FACE="New Century Schlbk,Century Schoolbook" SIZE=2>consult, restart, 
      load, list, trace, how, exit</FONT></P>
    <P><FONT FACE="New Century Schlbk,Century Schoolbook" SIZE=2><B>:trace on</B></FONT></P>
    <P><FONT FACE="New Century Schlbk,Century Schoolbook" SIZE=2>consult, restart, 
      load, list, trace, how, exit</FONT></P>
    <P><FONT FACE="New Century Schlbk,Century Schoolbook" SIZE=2>:consult</FONT></P>
    <P><FONT FACE="New Century Schlbk,Century Schoolbook" SIZE=2><B>call rule 
      1 </B></FONT></P>
    <P><FONT FACE="New Century Schlbk,Century Schoolbook" SIZE=2>Does the engine 
      turn over?</FONT></P>
    <P><FONT FACE="New Century Schlbk,Century Schoolbook" SIZE=2>: no</FONT></P>
    <P><FONT FACE="New Century Schlbk,Century Schoolbook" SIZE=2><B>call rule 
      2 </B></FONT></P>
    <P><FONT FACE="New Century Schlbk,Century Schoolbook" SIZE=2>Are the lights 
      weak?</FONT></P>
    <P><FONT FACE="New Century Schlbk,Century Schoolbook" SIZE=2>: yes</FONT></P>
    <P><FONT FACE="New Century Schlbk,Century Schoolbook" SIZE=2><B>exit rule 
      2 </B></FONT></P>
    <P><FONT FACE="New Century Schlbk,Century Schoolbook" SIZE=2><B>call rule 
      3 </B></FONT></P>
    <P><FONT FACE="New Century Schlbk,Century Schoolbook" SIZE=2>Is the radio 
      weak?</FONT></P>
    <P><FONT FACE="New Century Schlbk,Century Schoolbook" SIZE=2>: yes</FONT></P>
    <P><FONT FACE="New Century Schlbk,Century Schoolbook" SIZE=2><B>exit rule 
      3 </B></FONT></P>
    <P><FONT FACE="New Century Schlbk,Century Schoolbook" SIZE=2><B>exit rule 
      1 </B></FONT></P>
    <P><FONT FACE="New Century Schlbk,Century Schoolbook" SIZE=2><B>call rule 
      4 </B></FONT></P>
    <P><FONT FACE="New Century Schlbk,Century Schoolbook" SIZE=2><B>fail rule 
      4</B></FONT></P>
    <P><FONT FACE="New Century Schlbk,Century Schoolbook" SIZE=2><B>call rule 
      5 </B></FONT></P>
    <P><FONT FACE="New Century Schlbk,Century Schoolbook" SIZE=2><B>fail rule 
      5</B></FONT></P>
    <P><FONT FACE="New Century Schlbk,Century Schoolbook" SIZE=2><B>call rule 
      6 </B></FONT></P>
    <P><FONT FACE="New Century Schlbk,Century Schoolbook" SIZE=2><B>fail rule 
      6</B></FONT></P>
    <P><FONT FACE="New Century Schlbk,Century Schoolbook" SIZE=2>problem-battery-cf-75</FONT></P>
    <P><FONT FACE="New Century Schlbk,Century Schoolbook" SIZE=2>done with problem</FONT></P>
  </DIR>
</DIR>
<P ALIGN="JUSTIFY"><FONT FACE="New Century Schlbk,Century Schoolbook" SIZE=2>Next 
  we can look at the use of why explanations. The user would ask why and get the 
  inference chain that led to the question. For example:</FONT></P>
<DIR> 
  <DIR> <B> </b> 
    <P><FONT FACE="New Century Schlbk,Century Schoolbook" SIZE=2>...</FONT></P>
    <P><FONT FACE="New Century Schlbk,Century Schoolbook" SIZE=2>Is the radio 
      weak?</FONT></P>
    <P><FONT FACE="New Century Schlbk,Century Schoolbook" SIZE=2><B>: why</B></FONT></P>
    <P><FONT FACE="New Century Schlbk,Century Schoolbook" SIZE=2>rule 3 </FONT></P>
    <P><FONT FACE="New Century Schlbk,Century Schoolbook" SIZE=2>If </FONT></P>
    <P><FONT FACE="New Century Schlbk,Century Schoolbook" SIZE=2> radio_weak </FONT></P>
    <P><FONT FACE="New Century Schlbk,Century Schoolbook" SIZE=2>Then </FONT></P>
    <P><FONT FACE="New Century Schlbk,Century Schoolbook" SIZE=2> battery_bad 
      50 </FONT></P>
    <P><FONT FACE="New Century Schlbk,Century Schoolbook" SIZE=2>rule 1 </FONT></P>
    <P><FONT FACE="New Century Schlbk,Century Schoolbook" SIZE=2>If </FONT></P>
    <P><FONT FACE="New Century Schlbk,Century Schoolbook" SIZE=2> not turn_over 
      </FONT></P>
    <P><FONT FACE="New Century Schlbk,Century Schoolbook" SIZE=2> battery_bad 
      </FONT></P>
    <P><FONT FACE="New Century Schlbk,Century Schoolbook" SIZE=2>Then </FONT></P>
    <P><FONT FACE="New Century Schlbk,Century Schoolbook" SIZE=2> problem is battery 
      100 </FONT></P>
    <P><FONT FACE="New Century Schlbk,Century Schoolbook" SIZE=2>goal problem 
      </FONT></P>
    <P><FONT FACE="New Century Schlbk,Century Schoolbook" SIZE=2>...</FONT></P>
  </DIR>
</DIR>
<P ALIGN="JUSTIFY"><FONT FACE="New Century Schlbk,Century Schoolbook" SIZE=2>Notice 
  that the why explanation gives the chain of rules, in reverse order, that led 
  to the question. In this case the <B>goal</B> <B>problem</B> led to rule 1 which 
  led to rule 3.</FONT></P>
<P ALIGN="JUSTIFY"><FONT FACE="New Century Schlbk,Century Schoolbook" SIZE=2>The 
  how explanations start with answers. For example, the system has just reported 
  that the problem is the battery. The user wants to know how this result was 
  derived.</FONT></P>
<DIR> 
  <DIR> <B> </b> 
    <P><FONT FACE="New Century Schlbk,Century Schoolbook" SIZE=2>...</FONT></P>
    <P><FONT FACE="New Century Schlbk,Century Schoolbook" SIZE=2>problem-battery-cf-75</FONT></P>
    <P><FONT FACE="New Century Schlbk,Century Schoolbook" SIZE=2>done with problem</FONT></P>
    <P><FONT FACE="New Century Schlbk,Century Schoolbook" SIZE=2>consult, restart, 
      load, list, trace, how, exit</FONT></P>
    <P><FONT FACE="New Century Schlbk,Century Schoolbook" SIZE=2><B>:how</B></FONT></P>
    <P><FONT FACE="New Century Schlbk,Century Schoolbook" SIZE=2>Goal?<B> problem 
      is battery</b></FONT></P>
    <P><FONT FACE="New Century Schlbk,Century Schoolbook" SIZE=2>problem is battery 
      was derived from rules: 1 </FONT></P>
    <P><FONT FACE="New Century Schlbk,Century Schoolbook" SIZE=2>rule 1 </FONT></P>
    <P><FONT FACE="New Century Schlbk,Century Schoolbook" SIZE=2>If </FONT></P>
    <P><FONT FACE="New Century Schlbk,Century Schoolbook" SIZE=2> not turn_over 
      </FONT></P>
    <P><FONT FACE="New Century Schlbk,Century Schoolbook" SIZE=2> battery_bad 
      </FONT></P>
    <P><FONT FACE="New Century Schlbk,Century Schoolbook" SIZE=2>Then </FONT></P>
    <P><FONT FACE="New Century Schlbk,Century Schoolbook" SIZE=2> problem is battery 
      100 </FONT></P>
  </DIR>
</DIR>
<P ALIGN="JUSTIFY"><FONT FACE="New Century Schlbk,Century Schoolbook" SIZE=2>In 
  this case the rule(s) which directly supported the result are listed. Next the 
  user wants to know how <B>battery_bad</B> was derived.</FONT></P>
<DIR> 
  <DIR> <B> </b> 
    <P><FONT FACE="New Century Schlbk,Century Schoolbook" SIZE=2>consult, restart, 
      load, list, trace, how, exit</FONT></P>
    <P><FONT FACE="New Century Schlbk,Century Schoolbook" SIZE=2><B>:how</B></FONT></P>
    <P><FONT FACE="New Century Schlbk,Century Schoolbook" SIZE=2>Goal?<B> battery_bad</b></FONT></P>
    <P><FONT FACE="New Century Schlbk,Century Schoolbook" SIZE=2>battery_bad was 
      derived from rules: 3 2 </FONT></P>
    <P><FONT FACE="New Century Schlbk,Century Schoolbook" SIZE=2>rule 3 </FONT></P>
    <P><FONT FACE="New Century Schlbk,Century Schoolbook" SIZE=2>If </FONT></P>
    <P><FONT FACE="New Century Schlbk,Century Schoolbook" SIZE=2> radio_weak </FONT></P>
    <P><FONT FACE="New Century Schlbk,Century Schoolbook" SIZE=2>Then </FONT></P>
    <P><FONT FACE="New Century Schlbk,Century Schoolbook" SIZE=2> battery_bad 
      50 </FONT></P>
    <P><FONT FACE="New Century Schlbk,Century Schoolbook" SIZE=2>rule 2 </FONT></P>
    <P><FONT FACE="New Century Schlbk,Century Schoolbook" SIZE=2>If </FONT></P>
    <P><FONT FACE="New Century Schlbk,Century Schoolbook" SIZE=2> lights_weak 
      </FONT></P>
    <P><FONT FACE="New Century Schlbk,Century Schoolbook" SIZE=2>Then </FONT></P>
    <P><FONT FACE="New Century Schlbk,Century Schoolbook" SIZE=2> battery_bad 
      50 </FONT></P>
  </DIR>
</DIR>
<P ALIGN="JUSTIFY"><FONT FACE="New Century Schlbk,Century Schoolbook" SIZE=2>In 
  this case there were two rules which supported the goal, and the system lists 
  them both.</FONT></P>
<P ALIGN="JUSTIFY"><FONT FACE="New Century Schlbk,Century Schoolbook" SIZE=2>Figure 
  4.1 shows the difference between how and why questions. The why questions occur 
  at the bottom of an inference chain, and the how questions occur at the top.</FONT></P>
<P ALIGN="CENTER"><FONT FACE="New Century Schlbk,Century Schoolbook" SIZE=2><BR>
  <IMG SRC="explanation4-1.gif" WIDTH=364 HEIGHT=257><BR>
  </FONT></P>
<P ALIGN="JUSTIFY"><FONT FACE="New Century Schlbk,Century Schoolbook" SIZE=1>Figure 
  4.1. Difference between how and why questions</FONT></P>
<h3 ALIGN="JUSTIFY"><B><FONT FACE="New Century Schlbk,Century Schoolbook"><a name="tracing"></a>Tracing</FONT></B></h3>
<P ALIGN="JUSTIFY"><FONT FACE="New Century Schlbk,Century Schoolbook" SIZE=2>The 
  first explanation addition to Clam will be the rule tracing facility. It will 
  behave similarly to the Prolog box model traces, and inform the user when a 
  rule is "call"ed, "exit"ed, or "fail"ed. It will use a special predicate <B>bugdisp</B> 
  to communicate trace information with the user. It will take as an argument 
  a list of terms to be written on a line.</FONT></P>
<TABLE CELLSPACING=0 BORDER=0 WIDTH=430>
  <TR> 
    <TD VALIGN="TOP"> 
      <P ALIGN="JUSTIFY"><FONT FACE="New Century Schlbk,Century Schoolbook" SIZE=2>To 
        make it a user option, <B>bugdisp</B> will only write if <B>ruletrace</B> 
        is true. The user will have a new high level command to turn tracing on 
        or off which will assert or retract <B>ruletrace</B>. We can then use 
        <B>bugdisp</B> to add any diagnostics printout we like to the program.</FONT> 
    </TD>
  </TR>
</TABLE>
<DIR> 
  <DIR> <FONT FACE="Courier" SIZE=2> </font> 
    <P><B><FONT FACE="New Century Schlbk,Century Schoolbook" SIZE=2>bugdisp(L) 
      :-<BR>
      ruletrace, <BR>
      write_line(L), !.</FONT></B></P>
    <P><B><FONT FACE="New Century Schlbk,Century Schoolbook" SIZE=2>bugdisp(_).</FONT></B></P>
    <P><B><FONT FACE="New Century Schlbk,Century Schoolbook" SIZE=2>write_line([]) 
      :- nl.</FONT></B></P>
    <P><B><FONT FACE="New Century Schlbk,Century Schoolbook" SIZE=2>write_line([H|T]) 
      :-<BR>
      write(H), <BR>
      tab(1), <BR>
      write_line(T).</FONT></B></P>
  </DIR>
</DIR>
<P ALIGN="JUSTIFY"><FONT FACE="New Century Schlbk,Century Schoolbook" SIZE=2>Here 
  is the new command added to the <B>do</B> predicate called by the command loop 
  predicate, <B>go</B>. It allows the user to turn tracing on or off by issuing 
  the command <B>trace(on)</B> or <B>trace(off)</B>.</FONT></P>
<DIR><B></b> 
  <DIR> 
    <P><B><FONT FACE="New Century Schlbk,Century Schoolbook" SIZE=2>do( trace(X) 
      ) :- set_trace(X), !.</FONT></B></P>
    <P><B><FONT FACE="New Century Schlbk,Century Schoolbook" SIZE=2>set_trace(off) 
      :-<BR>
      ruletrace, <BR>
      retract( ruletrace ).</FONT></B></P>
    <P><B><FONT FACE="New Century Schlbk,Century Schoolbook" SIZE=2>set_trace(on) 
      :-<BR>
      not ruletrace, <BR>
      asserta( ruletrace ).</FONT></B></P>
    <P><B><FONT FACE="New Century Schlbk,Century Schoolbook" SIZE=2>set_trace(_).</FONT></B></P>
  </DIR>
</DIR>
<P ALIGN="JUSTIFY"><FONT FACE="New Century Schlbk,Century Schoolbook" SIZE=2>Now 
  that we have the tools for displaying trace information, we need to add <B>bugdisp</B> 
  calls in the predicate which recursively tries rules, <B>fg</B>. It is easy 
  to determine in <B>fg</B> when a rule is called and when it has been successful. 
  After the call to <B>rule</B> succeeds, the rule has been called. After the 
  call to <B>prove</B>, the rule has been successfully fired. The new code for 
  the predicate is added in bold. <BR>
  </FONT></P>
<DIR> 
  <DIR> 
    <P><FONT FACE="New Century Schlbk,Century Schoolbook" SIZE=2>fg(Goal, CurCF) 
      :-<BR>
      rule(N, lhs(IfList), rhs(Goal, CF)), <BR>
      <B>bugdisp(['call rule', N]), <BR>
      </B>prove(N, IfList, Tally), <BR>
      <B>bugdisp(['exit rule', N]), <BR>
      </B>adjust(CF, Tally, NewCF), <BR>
      update(Goal, NewCF, CurCF, N), <BR>
      CurCF == 100, !.</FONT></P>
    <P><FONT FACE="New Century Schlbk,Century Schoolbook" SIZE=2>fg(Goal, CF) 
      :- fact(Goal, CF).</FONT></P>
  </DIR>
</DIR>
<P ALIGN="JUSTIFY"><FONT FACE="New Century Schlbk,Century Schoolbook" SIZE=2>All 
  that remains is to capture rules that fail after being called. The place to 
  do this is in a second clause to <B>prove, </B>which is called when the first 
  clause fails. The second clause informs the user of the failure, and continues 
  to fail.</FONT></P>
<DIR> 
  <DIR> <B> </b> 
    <P><FONT FACE="New Century Schlbk,Century Schoolbook" SIZE=2>prove(N, IfList, 
      Tally) :-<BR>
      prov(IfList, 100, Tally), !.</FONT></P>
    <P><FONT FACE="New Century Schlbk,Century Schoolbook" SIZE=2><B>prove(N, _, 
      _) :-<BR>
      bugdisp(['fail rule', N]), <BR>
      fail.</B></FONT></P>
  </DIR>
</DIR>
<h3 ALIGN="JUSTIFY"><B><FONT FACE="New Century Schlbk,Century Schoolbook"><a name="howexplanations"></a>How 
  Explanations</FONT></B></h3>
<P ALIGN="JUSTIFY"><FONT FACE="New Century Schlbk,Century Schoolbook" SIZE=2>The 
  next explanation feature to implement is how. The how question is asked by the 
  user to see the proof of some conclusion the system has reached. The proof can 
  be generated by either rederiving the result with extra tracing, or by having 
  the original derivation stored in working storage. Clam uses the second option 
  and stores derivation information with the <B>fact</B> in working storage. Each 
  fact might have been derived from multiple rules, all concluding the same attribute 
  value pair and combining certainty factors. For this reason, a list of rule 
  numbers is stored as the third argument to <B>fact</B>. This is not the entire 
  proof tree, but just those rules which conclude the fact directly.</FONT></P>
<DIR> 
  <DIR> 
    <P><FONT FACE="New Century Schlbk,Century Schoolbook" SIZE=2><B>fact(AV, CF, 
      RuleList)</B></FONT></P>
  </DIR>
</DIR>
<P ALIGN="JUSTIFY"><FONT FACE="New Century Schlbk,Century Schoolbook" SIZE=2>A 
  <B>fact</B> is updated by <B>update</B>, so this is where the derivation is 
  captured. A new argument is added to <B>update</B> which is the rule number 
  that caused the update. Note that the first clause of <B>update</B> adds the 
  new rule number to the list of existing derivation rule numbers for the <B>fact</B>. 
  The second clause merely creates a new list with a single element. </FONT></P>
<DIR> 
  <DIR> 
    <P><FONT FACE="New Century Schlbk,Century Schoolbook" SIZE=2>update(Goal, 
      NewCF, CF<B>, RuleN</B>) :-<BR>
      fact(Goal, OldCF<B>, _</B>), <BR>
      combine(NewCF, OldCF, CF), <BR>
      retract( fact(Goal, OldCF<B>, OldRules</B>) ), <BR>
      asserta( fact(Goal, CF<B>, [RuleN | OldRules]</B>) ), !.</FONT></P>
    <P><FONT FACE="New Century Schlbk,Century Schoolbook" SIZE=2>update(Goal, 
      CF, CF<B>, RuleN</B>) :-<BR>
      asserta( fact(Goal, CF<B>, [RuleN]</B>) ).</FONT></P>
  </DIR>
</DIR>
<P ALIGN="JUSTIFY"><FONT FACE="New Century Schlbk,Century Schoolbook" SIZE=2>The 
  call to update from fg is modified to fill in the new argument with a rule number:</FONT></P>
<DIR> 
  <DIR> 
    <P><FONT FACE="New Century Schlbk,Century Schoolbook" SIZE=2>fg(Goal, CurCF) 
      :-<BR>
      rule(N, lhs(IfList), rhs(Goal, CF)), <BR>
      ...<BR>
      update(Goal, NewCF, CurCF<B>, N</B>), <BR>
      ...</FONT></P>
  </DIR>
</DIR>
<P ALIGN="JUSTIFY"><FONT FACE="New Century Schlbk,Century Schoolbook" SIZE=2>Now 
  that the supporting rules for each derived fact are in working storage we can 
  answer a user's question about how a fact was derived. The simplest thing to 
  do is to have <B>how</B> simply write the list of rules used. It is probably 
  of more interest to the user to actually display the rules as well. The predicate 
  <B>list_rules</B> does that.</FONT></P>
<DIR> 
  <DIR> 
    <P><FONT FACE="New Century Schlbk,Century Schoolbook" SIZE=2><B>how(Goal) 
      :-<BR>
      fact(Goal, CF, Rules), <BR>
      CF &gt; 20, <BR>
      pretty(Goal, PG), <BR>
      write_line([PG, was, derived, from, 'rules: '|Rules]), <BR>
      nl, <BR>
      list_rules(Rules), <BR>
      fail.</B></FONT></P>
    <P><FONT FACE="New Century Schlbk,Century Schoolbook" SIZE=2><B>how(_).</B></FONT></P>
  </DIR>
</DIR>
<P ALIGN="JUSTIFY"><FONT FACE="New Century Schlbk,Century Schoolbook" SIZE=2>The 
  <B>how</B> predicate for negated goals is similar and uses the fact that negation 
  is represented by a negative CF.</FONT></P>
<DIR> 
  <DIR> 
    <P><FONT FACE="New Century Schlbk,Century Schoolbook" SIZE=2><B>how(not Goal) 
      :-<BR>
      fact(Goal, CF, Rules), <BR>
      CF &lt; -20, <BR>
      pretty(not Goal, PG), <BR>
      write_line([PG, was, derived, from, 'rules: '|Rules]), <BR>
      nl, <BR>
      list_rules(Rules), <BR>
      fail.</B></FONT></P>
  </DIR>
</DIR>
<P ALIGN="JUSTIFY"><FONT FACE="New Century Schlbk,Century Schoolbook" SIZE=2>The 
  <B>pretty</B> predicate is used to convert <B>av</B> structures into a more 
  readable list and visa versa.</FONT></P>
<DIR> 
  <DIR> 
    <P><FONT FACE="New Century Schlbk,Century Schoolbook" SIZE=2><B>pretty(av(A, 
      yes), [A]) :- !.</B></FONT></P>
    <P><FONT FACE="New Century Schlbk,Century Schoolbook" SIZE=2><B>pretty(not 
      av(A, yes), [not, A]) :- !.</B></FONT></P>
    <P><FONT FACE="New Century Schlbk,Century Schoolbook" SIZE=2><B>pretty(av(A, 
      no), [not, A]) :- !.</B></FONT></P>
    <P><FONT FACE="New Century Schlbk,Century Schoolbook" SIZE=2><B>pretty(not 
      av(A, V), [not, A, is, V]).</B></FONT></P>
    <P><FONT FACE="New Century Schlbk,Century Schoolbook" SIZE=2><B>pretty(av(A, 
      V), [A, is, V]).</B></FONT></P>
  </DIR>
</DIR>
<P ALIGN="JUSTIFY"><FONT FACE="New Century Schlbk,Century Schoolbook" SIZE=2>The 
  <B>list_rules</B> predicate writes a formatted listing of each rule used in 
  deriving a given fact.</FONT></P>
<DIR> 
  <DIR> 
    <P><FONT FACE="New Century Schlbk,Century Schoolbook" SIZE=2><B>list_rules([]).</B></FONT></P>
    <P><FONT FACE="New Century Schlbk,Century Schoolbook" SIZE=2><B>list_rules([R|X]) 
      :-<BR>
      list_rule(R), <BR>
      list_rules(X).</B></FONT></P>
    <P><FONT FACE="New Century Schlbk,Century Schoolbook" SIZE=2><B>list_rule(N) 
      :-<BR>
      rule(N, lhs(Iflist), rhs(Goal, CF)), <BR>
      write_line(['rule ', N]), <BR>
      write_line(['If']), <BR>
      write_ifs(Iflist), <BR>
      write_line(['Then']), <BR>
      pretty(Goal, PG), <BR>
      write_line([' ', PG, CF]), nl.</B></FONT></P>
    <P><FONT FACE="New Century Schlbk,Century Schoolbook" SIZE=2><B>write_ifs([]).</B></FONT></P>
    <P><FONT FACE="New Century Schlbk,Century Schoolbook" SIZE=2><B>write_ifs([H|T]) 
      :-<BR>
      pretty(H, HP), <BR>
      tab(5), write_line(HP), <BR>
      write_ifs(T).</B></FONT></P>
  </DIR>
</DIR>
<P ALIGN="JUSTIFY"><FONT FACE="New Century Schlbk,Century Schoolbook" SIZE=2>We 
  can use <B>pretty</B> in reverse, along with a predicate that reads a list of 
  tokens from a line to provide a nicer interface to the user for how questions. 
  In this way the user doesn't have to specify the internal form of the fact.</FONT></P>
<DIR> 
  <DIR> 
    <P><FONT FACE="New Century Schlbk,Century Schoolbook" SIZE=2><B>how :-<BR>
      write('Goal? '), read_line(X), nl, <BR>
      pretty(Goal, X), <BR>
      how(Goal).</B></FONT></P>
  </DIR>
</DIR>
<P ALIGN="JUSTIFY"><FONT FACE="New Century Schlbk,Century Schoolbook" SIZE=2>The 
  how command can now be added as part of the top level user interface:</FONT></P>
<DIR> 
  <DIR> 
    <P><FONT FACE="New Century Schlbk,Century Schoolbook" SIZE=2><B>do(how) :- 
      how, !.</B></FONT></P>
  </DIR>
</DIR>
<P ALIGN="JUSTIFY"><FONT FACE="New Century Schlbk,Century Schoolbook" SIZE=2>The 
  full <B>how</B> command as coded above just displays for the user the rules 
  directly responsible for a fact. These rules themselves are likely based on 
  other facts which were derived as well. There are two ways of presenting this 
  information:</FONT></P>
<P ALIGN="JUSTIFY"> 
<FONT FACE="New Century Schlbk,Century Schoolbook" SIZE=2> 
<P ALIGN="JUSTIFY"> </P>
</FONT> 
<DIR> 
  <DIR> 
    <P ALIGN="JUSTIFY"><FONT FACE="New Century Schlbk,Century Schoolbook" SIZE=2>•&#9;let 
      the user ask further <B>how</B>s of the various rules' left hand side goals 
      to delve deeper into the proof tree;</FONT></P>
    <P ALIGN="JUSTIFY"> 
    <FONT FACE="New Century Schlbk,Century Schoolbook" SIZE=2> 
    <P ALIGN="JUSTIFY"> </P>
    </FONT> 
    <P ALIGN="JUSTIFY"><FONT FACE="New Century Schlbk,Century Schoolbook" SIZE=2>•&#9;have 
      <B>how</B> automatically display the entire proof tree.</FONT></P>
    <P ALIGN="JUSTIFY"> 
    <FONT FACE="New Century Schlbk,Century Schoolbook" SIZE=2> 
    <P ALIGN="JUSTIFY"> </P>
    </FONT> </DIR>
</DIR>
<P ALIGN="JUSTIFY"><FONT FACE="New Century Schlbk,Century Schoolbook" SIZE=2>So 
  far we have chosen the first. In order to implement the second choice, a predicate 
  <B>how_lhs</B> needs to be written which will trace the full tree by recursively 
  calling <B>how</B> for each of the goals in the <B>Iflist</B> of the rule.</FONT></P>
<DIR> 
  <DIR> 
    <P><FONT FACE="New Century Schlbk,Century Schoolbook" SIZE=2>list_rules([]).</FONT></P>
    <P><FONT FACE="New Century Schlbk,Century Schoolbook" SIZE=2>list_rules([R|X]) 
      :-<BR>
      list_rule(R), <BR>
      <B>how_lhs(R), <BR>
      </B>list_rules(X).</FONT></P>
    <P><FONT FACE="New Century Schlbk,Century Schoolbook" SIZE=2><B>how_lhs(N) 
      :-<BR>
      rule(N, lhs(Iflist), _), <BR>
      !, how_ifs(Iflist).<BR>
      </B></FONT></P>
    <P><FONT FACE="New Century Schlbk,Century Schoolbook" SIZE=2><B>how_ifs([]).</B></FONT></P>
    <P><FONT FACE="New Century Schlbk,Century Schoolbook" SIZE=2><B>how_ifs([Goal|X]) 
      :-<BR>
      how(Goal), <BR>
      how_ifs(X).</B></FONT></P>
  </DIR>
</DIR>
<P ALIGN="JUSTIFY"><FONT FACE="New Century Schlbk,Century Schoolbook" SIZE=2>The 
  three choices of user interface for hows (just rule numbers, listings of direct 
  rules, list of full proof tree) shows some of the problems with shells and the 
  advantages of a toolbox approach. In a customized expert system, the options 
  which makes the most sense for the application can be used. In a generalized 
  system the designer is faced with two unpleasant choices. One is to keep the 
  system easy to use and pick one option for all users. The other is to give the 
  flexibility to the user and provide all three, thus making the product more 
  complex for the user to learn.</FONT></P>
<h3 ALIGN="JUSTIFY"><B><FONT FACE="New Century Schlbk,Century Schoolbook"><a name="whyquestions"></a>Why 
  Questions</FONT></B></h3>
<P ALIGN="JUSTIFY"><FONT FACE="New Century Schlbk,Century Schoolbook" SIZE=2>The 
  <B>how</B> question is asked from the top level of an inference, after the inference 
  has been completed. The <B>why</B> question is asked at the bottom of a chain 
  of rules when there are no more rules and it is time to ask the user. The user 
  wants to know <B>why</B> the question is being asked.</FONT></P>
<TABLE CELLSPACING=0 BORDER=0 WIDTH=430>
  <TR> 
    <TD VALIGN="TOP"> 
      <P ALIGN="JUSTIFY"><FONT FACE="New Century Schlbk,Century Schoolbook" SIZE=2>In 
        order to be able to answer this type of question, we must keep track of 
        the inference chain that led to the question to the user. One way to do 
        this is to keep an extra argument in the inference predicates that contains 
        the chain of rules above it in the inference. This is done in <B>findgoal</B> 
        and <B>prove</B>. Each keeps a separate argument <B>Hist</B> which is 
        the desired list of rules. The list is initially the empty list at the 
        top call to <B>findgoal</B>.</FONT> 
    </TD>
  </TR>
</TABLE>
<B></B> 
<DIR><FONT FACE="New Century Schlbk,Century Schoolbook" SIZE=2></font> 
  <DIR> <FONT FACE="New Century Schlbk,Century Schoolbook" SIZE=2><B> </b></font> 
    <P><FONT FACE="New Century Schlbk,Century Schoolbook" SIZE=2>findgoal(Goal, 
      CurCF<B>, Hist</B>) :-<BR>
      fg(Goal, CurCF<B>, Hist</B>).<BR>
      </FONT></P>
    <P><FONT FACE="New Century Schlbk,Century Schoolbook" SIZE=2>fg(Goal, CurCF<B>, 
      Hist</B>) :-<BR>
      ...<BR>
      prove(N, IfList, Tally<B>, Hist</B>), <BR>
      ...</FONT></P>
  </DIR>
</DIR>
<P ALIGN="JUSTIFY"><FONT FACE="New Century Schlbk,Century Schoolbook" SIZE=2>The 
  <B>prove</B> predicate maintains the list by adding the current rule number 
  on the head of the list before a recursive call to <B>findgoal</B>. The calls 
  further down the recursion have this new rule number available for answers to 
  <B>why</B> questions. Notice that both Prolog's recursive behavior and backtracking 
  assure that the history is correct at any level of call.</FONT></P>
<DIR> 
  <DIR> <B> </b> 
    <P><FONT FACE="New Century Schlbk,Century Schoolbook" SIZE=2>prove(N, IfList, 
      Tally<B>, Hist</B>) :-<BR>
      prov(IfList, 100, Tally, <B>[N|Hist]</B>), !.</FONT></P>
    <P><FONT FACE="New Century Schlbk,Century Schoolbook" SIZE=2>prove(N, _<B>, 
      _</B>) :-<BR>
      bugdisp(['fail rule', N]), <BR>
      fail.</FONT></P>
    <P><FONT FACE="New Century Schlbk,Century Schoolbook" SIZE=2>prov([], Tally, 
      Tally<B>, Hist</B>).</FONT></P>
    <P><FONT FACE="New Century Schlbk,Century Schoolbook" SIZE=2>prov([H|T], CurTal, 
      Tally<B>, Hist</B>) :-<BR>
      findgoal(H, CF<B>, Hist</B>), <BR>
      min(CurTal, CF, Tal), <BR>
      Tal &gt;= 20, <BR>
      prov(T, Tal, Tally<B>, Hist</B>).</FONT></P>
  </DIR>
</DIR>
<P ALIGN="JUSTIFY"><FONT FACE="New Century Schlbk,Century Schoolbook" SIZE=2>Finally, 
  we need to give the user the ability to ask the why question without disturbing 
  the dialog. This means replacing the old <B>read</B>s of user input with a new 
  predicate, <B>get_user</B> which gets an answer from the user and processes 
  it as a <B>why</B> command if necessary. <B>Hist</B> is of course passed down 
  as an argument and is available for <B>get_user</B> to process. Also, rather 
  than just displaying rule numbers, we can list the rules for the user as well.</FONT></P>
<P ALIGN="JUSTIFY"><FONT FACE="New Century Schlbk,Century Schoolbook" SIZE=2>The 
  <B>process_ans</B> predicate first looks for command patterns and behaves accordingly. 
  If it is a command, the command is executed and then failure is invoked causing 
  the system to backtrack and reask the user for an answer.</FONT></P>
<P ALIGN="JUSTIFY"><FONT FACE="New Century Schlbk,Century Schoolbook" SIZE=2>Note 
  that now that we are capturing and interpreting the user's response with more 
  intelligence, we can give the user more options. For example, at the question 
  level he/she can turn tracing on or off for the duration of the session, ask 
  a how question, or request help. These are all easily added options for the 
  implementer.</FONT></P>
<DIR> 
  <DIR> 
    <P><FONT FACE="New Century Schlbk,Century Schoolbook" SIZE=2><B>get_user(X, 
      Hist) :-<BR>
      repeat, <BR>
      write(': '), <BR>
      read_line(X), <BR>
      process_ans(X, Hist).</B></FONT></P>
    <P><FONT FACE="New Century Schlbk,Century Schoolbook" SIZE=2><B>process_ans([why], 
      Hist) :- nl, write_hist(Hist), !, fail.</B></FONT></P>
    <P><FONT FACE="New Century Schlbk,Century Schoolbook" SIZE=2><B>process_ans([trace, 
      X], _) :- set_trace(X), !, fail.</B></FONT></P>
    <P><FONT FACE="New Century Schlbk,Century Schoolbook" SIZE=2><B>process_ans([help], 
      _) :- help, !, fail.</B></FONT></P>
    <P><FONT FACE="New Century Schlbk,Century Schoolbook" SIZE=2><B>process_ans(X, 
      _).&#9;</b>% just return user's answer</FONT></P>
    <P><FONT FACE="New Century Schlbk,Century Schoolbook" SIZE=2><B>write_hist([]) 
      :- nl.</B></FONT></P>
    <P><FONT FACE="New Century Schlbk,Century Schoolbook" SIZE=2><B>write_hist([goal(X)|T]) 
      :-<BR>
      write_line([goal, X]), <BR>
      !, write_hist(T).</B></FONT></P>
    <P><FONT FACE="New Century Schlbk,Century Schoolbook" SIZE=2><B>write_hist([N|T]) 
      :-<BR>
      list_rule(N), <BR>
      !, write_hist(T).</B></FONT></P>
  </DIR>
</DIR>
<h2><B><FONT FACE="New Century Schlbk,Century Schoolbook"> <a name="nativeprologsystems"></a>4.2 
  Native Prolog Systems </font></B></h2>
<P ALIGN="JUSTIFY"><FONT FACE="New Century Schlbk,Century Schoolbook" SIZE=2>Since 
  we wrote the inference engine for Clam, it was easy to modify it to add the 
  code for explanations. However, when we use pure Prolog, we don't have access 
  to the inference engine.</FONT></P>
<P ALIGN="JUSTIFY"><FONT FACE="New Century Schlbk,Century Schoolbook" SIZE=2>This 
  problem is easily solved. We simply write a Prolog inference engine in Prolog. 
  Then, having written the inference engine, we can modify it to handle explanations.</FONT></P>
<P ALIGN="JUSTIFY"><FONT FACE="New Century Schlbk,Century Schoolbook" SIZE=2>An 
  inference engine has to have access to the rules. In Prolog, the clauses are 
  themselves just Prolog terms. The built-in predicate <B>clause</B> gives us 
  access to the rules. It has two arguments which unify with the head of a clause 
  and its body. A fact has a body with just the goal true.</FONT></P>
<P ALIGN="JUSTIFY"><FONT FACE="New Century Schlbk,Century Schoolbook" SIZE=2>Predicates 
  which manipulate Prolog clauses are confusing to read due to the ambiguous use 
  of the comma in Prolog. It can be either: an operator used to separate the subgoals 
  in a clause; or a syntactic separator of functor arguments. Prolog clauses are 
  just Prolog terms with functors of ":-" and ",". Just for now, pretend Prolog 
  used an "&amp;" operator to separate goals rather than a "," operator. Then 
  a clause would look like:</FONT></P>
<DIR> 
  <DIR> 
    <P><FONT FACE="New Century Schlbk,Century Schoolbook" SIZE=2><B>a :- b &amp; 
      c &amp; d.</B></FONT></P>
  </DIR>
</DIR>
<P ALIGN="JUSTIFY"><FONT FACE="New Century Schlbk,Century Schoolbook" SIZE=2>Without 
  the operator definitions it would look like:</FONT></P>
<DIR> 
  <DIR> 
    <P><FONT FACE="New Century Schlbk,Century Schoolbook" SIZE=2><B>:-(a, &amp;(b, 
      &amp;(c, d))).</B></FONT></P>
  </DIR>
</DIR>
<P ALIGN="JUSTIFY"><FONT FACE="New Century Schlbk,Century Schoolbook" SIZE=2>The 
  <B>clause</B> built-in predicate picks up the first and second arguments of 
  the ":-" functor. It will find the entire Prolog database on backtracking. If 
  patterns are specified in either argument, then only clauses which unify with 
  the patterns are found. For the above clause:</FONT></P>
<DIR> 
  <DIR> 
    <P><FONT FACE="New Century Schlbk,Century Schoolbook" SIZE=2><B>?- clause(Head, 
      Body).</B></FONT></P>
    <P><FONT FACE="New Century Schlbk,Century Schoolbook" SIZE=2><B>Head = a</B></FONT></P>
    <P><FONT FACE="New Century Schlbk,Century Schoolbook" SIZE=2><B>Body = b &amp; 
      c &amp; d</B></FONT></P>
  </DIR>
</DIR>
<P ALIGN="JUSTIFY"><FONT FACE="New Century Schlbk,Century Schoolbook" SIZE=2>A 
  recursive predicate working through the goals in <B>Body</B> would look like:</FONT></P>
<DIR> 
  <DIR> 
    <P><FONT FACE="New Century Schlbk,Century Schoolbook" SIZE=2><B>recurse(FirstGoal 
      &amp; RemainingGoals) :-<BR>
      process(FirstGoal),<BR>
      recurse(RemainingGoals).</B></FONT></P>
    <P><FONT FACE="New Century Schlbk,Century Schoolbook" SIZE=2><B>recurse(SingleGoal) 
      :-<BR>
      process(SingleGoal).</B></FONT></P>
  </DIR>
</DIR>
<P ALIGN="JUSTIFY"><FONT FACE="New Century Schlbk,Century Schoolbook" SIZE=2>The 
  use of "&amp;" was just to distinguish between the two commas in Prolog. To 
  resolve ambiguous references to commas as in the first line of the above code, 
  parenthesis are used. The first line should really be written:</FONT></P>
<DIR> 
  <DIR> 
    <P><FONT FACE="New Century Schlbk,Century Schoolbook" SIZE=2><B>recurse( (FirstGoal, 
      RemainingGoals) ) :-<BR>
      ...</B></FONT></P>
  </DIR>
</DIR>
<P ALIGN="JUSTIFY"><FONT FACE="New Century Schlbk,Century Schoolbook" SIZE=2>See 
  Clocksin &amp; Mellish Section 2.3, <I>Operators</I> for a full discussion of 
  operators.</FONT></P>
<P ALIGN="JUSTIFY"><FONT FACE="New Century Schlbk,Century Schoolbook" SIZE=2> 
  Given the means to access and manipulate the Prolog database of facts and rules, 
  a simple Prolog interpreter that proves a list of goals (goals separated by 
  the "," operator) would look like:</FONT></P>
<DIR> 
  <DIR> 
    <P><FONT FACE="New Century Schlbk,Century Schoolbook" SIZE=2><B>prove(true) 
      :- !.</B></FONT></P>
    <P><FONT FACE="New Century Schlbk,Century Schoolbook" SIZE=2><B>prove((Goal, 
      Rest)) :-<BR>
      clause(Goal, Body), <BR>
      prove(Body), <BR>
      prove(Rest).</B></FONT></P>
    <P><FONT FACE="New Century Schlbk,Century Schoolbook" SIZE=2><B>prove(Goal) 
      :-<BR>
      clause(Goal, Body),<BR>
      prove(Body).</B></FONT></P>
  </DIR>
</DIR>
<P ALIGN="JUSTIFY"><FONT FACE="New Century Schlbk,Century Schoolbook" SIZE=2>Notice 
  that <B>prove</B> mimics precisely Prolog's behavior. First it finds a clause 
  whose head matches the first goal. Then it proves the list of goals in the <B>Body</B> 
  of the clause. Notice that unification automatically occurs between the <B>Goal</B> 
  for the head of the clause and the <B>Body</B>. This is because the Prolog clause 
  is just a Prolog term. If it succeeds, it continues with the rest of the goals 
  in the list. It it fails, it backtracks and finds the next clause whose head 
  unifies with the <B>Goal</B>.</FONT></P>
<P ALIGN="JUSTIFY"><FONT FACE="New Century Schlbk,Century Schoolbook" SIZE=2>This 
  interpreter will only handle pure Prolog whose clauses are asserted in the database. 
  It has no provisions for built-in predicates. These could be included by adding 
  a final catchall clause:</FONT></P>
<DIR> 
  <DIR> 
    <P><FONT FACE="New Century Schlbk,Century Schoolbook" SIZE=2><B>prove(X) :- 
      call(X).</B></FONT></P>
  </DIR>
</DIR>
<P ALIGN="JUSTIFY"><FONT FACE="New Century Schlbk,Century Schoolbook" SIZE=2>For 
  Native we do not intend to have Prolog built-in predicates, but we do intend 
  to call <B>ask</B> and <B>menuask</B>. For the Native shell these are our own 
  built-in predicates.</FONT></P>
<P ALIGN="JUSTIFY"><FONT FACE="New Century Schlbk,Century Schoolbook" SIZE=2>We 
  will make some basic modifications to our Prolog interpreter to allow it to 
  handle our own built-in predicates and record information for explanations. 
  First, we write an intermediate predicate <B>prov</B> that calls <B>clause</B>. 
  It can also check for built-in predicates such as <B>ask</B> and <B>menuask</B> 
  in the system. If the goal is either of these, they are just called with real 
  Prolog.</FONT></P>
<P ALIGN="JUSTIFY"><FONT FACE="New Century Schlbk,Century Schoolbook" SIZE=2>Next 
  we add an extra argument, just as we did for Clam. The extra argument keeps 
  track of the level of nesting of a particular goal. By passing this history 
  along to the <B>ask</B> predicates, the <B>ask</B> predicates can now respond 
  to <B>why</B> questions.</FONT></P>
<DIR> 
  <DIR> <B> </b> 
    <P><FONT FACE="New Century Schlbk,Century Schoolbook" SIZE=2>prove(true, _) 
      :- !.</FONT></P>
    <P><FONT FACE="New Century Schlbk,Century Schoolbook" SIZE=2>prove((Goal, 
      Rest)<B>, Hist</B>) :-<BR>
      prov(Goal<B>, (Goal, Rest)</B>), <BR>
      prove(Rest<B>, Hist</B>).</FONT></P>
    <P><FONT FACE="New Century Schlbk,Century Schoolbook" SIZE=2><B>prov(true, 
      _) :- !.</B></FONT></P>
    <P><FONT FACE="New Century Schlbk,Century Schoolbook" SIZE=2><B>prov(menuask(X, 
      Y, Z), Hist) :- menuask(X, Y, Z, Hist), !.</B></FONT></P>
    <P><FONT FACE="New Century Schlbk,Century Schoolbook" SIZE=2><B>prov(ask(X, 
      Y), Hist) :- ask(X, Y, Hist), !.</B></FONT></P>
    <P><FONT FACE="New Century Schlbk,Century Schoolbook" SIZE=2><B>prov(Goal, 
      Hist) :-<BR>
      clause(Goal, List), <BR>
      prove(List, [Goal|Hist]).</B></FONT></P>
  </DIR>
</DIR>
<P ALIGN="JUSTIFY"><FONT FACE="New Century Schlbk,Century Schoolbook" SIZE=2>Notice 
  that the history is a list of goals, and not the full rules as saved in Clam.</FONT></P>
<P ALIGN="JUSTIFY"><FONT FACE="New Century Schlbk,Century Schoolbook" SIZE=2>The 
  next step is to modify the top level predicate which looks for birds. First 
  add an empty history list as an argument to the top call of prove:</FONT></P>
<DIR> 
  <DIR> <B> </b> 
    <P><FONT FACE="New Century Schlbk,Century Schoolbook" SIZE=2>solve :-<BR>
      abolish(known, 3), <BR>
      define(known, 3), <BR>
      <B>prove(top_goal(X), []), <BR>
      </B>write('The answer is '), write(X), nl.</FONT></P>
    <P><FONT FACE="New Century Schlbk,Century Schoolbook" SIZE=2>solve :-<BR>
      write('No answer found'), nl.</FONT></P>
  </DIR>
</DIR>
<P ALIGN="JUSTIFY"><FONT FACE="New Century Schlbk,Century Schoolbook" SIZE=2>The 
  processing of <B>why</B> questions is the same as in Clam.</FONT></P>
<DIR> 
  <DIR> 
    <P><FONT FACE="New Century Schlbk,Century Schoolbook" SIZE=2><B>get_user(X, 
      Hist) :-<BR>
      repeat, <BR>
      read(X), <BR>
      process_ans(X, Hist), !.</B></FONT></P>
    <P><FONT FACE="New Century Schlbk,Century Schoolbook" SIZE=2><B>process_ans(why, 
      Hist) :-<BR>
      write(Hist), !, fail.</B></FONT></P>
    <P><FONT FACE="New Century Schlbk,Century Schoolbook" SIZE=2><B>process_ans(X, 
      _).&#9;</B></FONT></P>
  </DIR>
</DIR>
<P ALIGN="JUSTIFY"><FONT FACE="New Century Schlbk,Century Schoolbook" SIZE=2>The 
  dialog with the user would look like:</FONT></P>
<DIR> 
  <DIR> 
    <P><FONT FACE="New Century Schlbk,Century Schoolbook" SIZE=2><B>?- identify.</B></FONT></P>
    <P><FONT FACE="New Century Schlbk,Century Schoolbook" SIZE=2>nostrils : external_tubular?<B> 
      why.</b></FONT></P>
    <P><FONT FACE="New Century Schlbk,Century Schoolbook" SIZE=2>[nostrils(external_tubular), 
      order(tubenose), family(albatross), bird(laysan_albatross)]</FONT></P>
    <P><FONT FACE="New Century Schlbk,Century Schoolbook" SIZE=2>nostrils : external_tubular?</FONT></P>
  </DIR>
</DIR>
<P ALIGN="JUSTIFY"><FONT FACE="New Century Schlbk,Century Schoolbook" SIZE=2>We 
  can further use <B>clause</B> to answer <B>how</B> questions. In Clam we chose 
  to save the derivations in the database. For native Prolog it is easier just 
  to rederive the answer.</FONT></P>
<DIR> 
  <DIR> 
    <P><FONT FACE="New Century Schlbk,Century Schoolbook" SIZE=2><B>how(Goal) 
      :-<BR>
      clause(Goal, List), <BR>
      prove(List, []), <BR>
      write(List).</B></FONT></P>
  </DIR>
</DIR>
<P ALIGN="JUSTIFY"><FONT FACE="New Century Schlbk,Century Schoolbook" SIZE=2>It 
  is also possible to ask <B>whynot</B> questions which determine why an expected 
  result was not reached. This also uses <B>clause</B> to find the clauses which 
  might have proved the goals, and goes through the list of goals looking for 
  the first one that failed. It is reported, and then backtracking causes any 
  other clauses which might have helped to be explained as well.</FONT></P>
<DIR> 
  <DIR> 
    <P><FONT FACE="New Century Schlbk,Century Schoolbook" SIZE=2><B>whynot(Goal) 
      :-<BR>
      clause(Goal, List), <BR>
      write_line([Goal, 'fails because: ']), <BR>
      explain(List).</B></FONT></P>
    <P><FONT FACE="New Century Schlbk,Century Schoolbook" SIZE=2><B>whynot(_).</B></FONT></P>
    <P><FONT FACE="New Century Schlbk,Century Schoolbook" SIZE=2><B>explain( (H, 
      T) ) :-<BR>
      check(H), <BR>
      explain(T).</B></FONT></P>
    <P><FONT FACE="New Century Schlbk,Century Schoolbook" SIZE=2><B>explain(H) 
      :-<BR>
      check(H).</B></FONT></P>
    <P><FONT FACE="New Century Schlbk,Century Schoolbook" SIZE=2><B>check(H) :- 
      prove(H, _), write_line([H, succeeds]), !.</B></FONT></P>
    <P><FONT FACE="New Century Schlbk,Century Schoolbook" SIZE=2><B>check(H) :- 
      write_line([H, fails]), fail.</B></FONT></P>
  </DIR>
</DIR>
<P ALIGN="JUSTIFY"><FONT FACE="New Century Schlbk,Century Schoolbook" SIZE=2>The 
  <B>whynot</B> predicate has the same design problems as <B>how</B>. Do we automatically 
  recurse through a whole failure tree, or do we let the user ask successive <B>whynot</B>'s 
  to delve deeper into the mystery. This version just gives the first level. By 
  adding a recursive call to <B>whynot</B> in the second clause of check, it would 
  print the whole story.</FONT></P>
<h2><B><FONT FACE="New Century Schlbk,Century Schoolbook"> <a name="exercises"></a>Exercises 
  </font></B></h2>
<P ALIGN="JUSTIFY"><FONT FACE="New Century Schlbk,Century Schoolbook" SIZE=2>4.1 
  - Implement whynot for Clam.</FONT></P>
<P ALIGN="JUSTIFY"> 
<FONT FACE="New Century Schlbk,Century Schoolbook" SIZE=2> 
<P ALIGN="JUSTIFY"> </P>
</FONT> 
<P ALIGN="JUSTIFY"><FONT FACE="New Century Schlbk,Century Schoolbook" SIZE=2>4.2 
  - Have whynot give a full failure history.</FONT></P>
<P ALIGN="JUSTIFY"> 
<FONT FACE="New Century Schlbk,Century Schoolbook" SIZE=2> 
<P ALIGN="JUSTIFY"> </P>
</FONT> 
<P ALIGN="JUSTIFY"><FONT FACE="New Century Schlbk,Century Schoolbook" SIZE=2>4.3 
  - Make sure the explanation facility can handle attribute object value triples 
  in both Clam and Native.</FONT></P>
<P ALIGN="JUSTIFY"> 
<FONT FACE="New Century Schlbk,Century Schoolbook" SIZE=2> 
<P ALIGN="JUSTIFY"> </P>
</FONT> 
<P ALIGN="JUSTIFY"><FONT FACE="New Century Schlbk,Century Schoolbook" SIZE=2>4.4 
  - Decide whether you like the full rules presented in answer to why questions 
  as in Clam, or just the goals as in Native. Make both systems behave the same 
  way.</FONT></P>
<P ALIGN="JUSTIFY"> 
<FONT FACE="New Century Schlbk,Century Schoolbook" SIZE=2> 
<P ALIGN="JUSTIFY"> </P>
</FONT> 
<P ALIGN="JUSTIFY"><FONT FACE="New Century Schlbk,Century Schoolbook" SIZE=2>4.5 
  - Enhance the trace function so it displays the goals currently being sought 
  by the system. Have various levels of trace information that can be controlled 
  by the trace command.</FONT></P>
<P ALIGN="JUSTIFY"> 
<FONT FACE="New Century Schlbk,Century Schoolbook" SIZE=2> 
<P ALIGN="JUSTIFY"> </P>
</FONT> 
<P ALIGN="JUSTIFY"><FONT FACE="New Century Schlbk,Century Schoolbook" SIZE=2>4.6 
  - Using <B>prove</B>, implement a Prolog trace function.</FONT></P>
<P ALIGN="JUSTIFY"> 
<FONT FACE="New Century Schlbk,Century Schoolbook" SIZE=2> 
<P ALIGN="JUSTIFY"> </P>
</FONT> 
<P><FONT FACE="New Century Schlbk,Century Schoolbook" SIZE=2>4.7 - Add a pretty 
  printing predicate for Native to use when displaying Prolog rules.</FONT></P>
<P><i><font size=-1>Copyright &copy;1989,2000 Amzi! inc. All Rights Reserved.</font></i></P>
</BODY>
</HTML>
